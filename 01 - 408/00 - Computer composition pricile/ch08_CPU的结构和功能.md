# 1. CPU的结构

## 1.1 CPU的功能

CPU实质包括运算器和控制器两大部分，这里重点介绍控制器的功能:

1. 取指令

   控制器必须具备自动地从存储器中取出指令的功能。为此，要求控制器能自动形成指令的地址，并能发出取指令的命令，将对应此地址的指令取到控制器中。

   第一条指令的地址可以人为定义，也可以由系统设定

2. 分析指令

   - 分析此指令要完成什么操作，即控制器需要发出什么操作命令
   - 分析参与此次操作的操作数地址，即操作数的有效地址

3. 执行指令

   根据分析指令产生的"操作命令"和"操作数地址"的要求，形成操作控制信号序列，通过对运算器、存储器以及I/O设备的操作，执行每条指令。

此外，控制器还必须能控制程序的输入和运算结果的输出以及对总线的管理，甚至能处理机器运行中出现的异常情况和特殊请求，即处理中断的能力。



## 1.2 CPU结构框图

CPU由以下四个部分组成:

<img src="./image/ch08_00_00.svg" style="display:block; margin:0 auto;">

将上图细化，有:

<img src="./image/ch08_00_01.svg" style="display:block; margin:0 auto;">

## 1.3 CPU的寄存器

CPU内的寄存器大致可分为两类

- 用户可见的寄存器，用户可对这类寄存器编程，以及通过优化使CPU因使用这里寄存器而减少对主存的访问次数
- 控制和状态控制寄存器，用户不可对这类寄存器编程，它们被控制部件使用，以控制CPU的操作，也可被带有特权的操作系统使用，从而控制程序执行

### 1.3.1 用户可见寄存器

1. 通用寄存器

   可由程序设计者指定许多功能，可用于存放操作数，也可作为满足某种寻址方式所需的寄存器。

2. 数据寄存器

   - 用于存放操作数，其位数应满足多数数据类型的数值范围。

   - 有些机器允许使用连续的两个寄存器存放双倍字长的值。

   - 还有的机器的数据寄存器只能用于保存数据，不能用于操作数的地址

3. 地址寄存器

   用于存放地址，其本身可以具有通用性，也可以用于特殊的寻址方式。

4. 条件码寄存器

   - 这类寄存器中存放条件码，它们对用户来说是部分透明的。

   - 条件码可被测试，作为分支运算的依据。

   - 有些条件码可以被设置，如：最高进位标志C，可用指令对它置位和复位。

   - 将条件码放在一个或多个寄存器中，就构成了条件码寄存器。

   - 在调用子程序前，必须将所有的用户可见寄存器内容保存起来，可由CPU自动完成，也可由程序员编程保存

### 1.3.2 控制和状态寄存器

   下面四种寄存器在指令过程中起重要作用:

   1. MAR

      存储器地址寄存器，用于存放将被访问的存储单元的位置

   2. MDR

      存储器数据寄存器，用于存放欲存入存储器中的数据或最近从存储器中读取处的数据

   3. PC

      程序计数器，存放现行指令的地址，通常具有计数功能。当遇到转移类指令时，PC的值可以被修改

   4. IR

      指令寄存器，存放当前欲执行的指令
      
      
      
      
      

通过这四个寄存器，CPU和主存可交换信息。

CPU内部必须给ALU提供数据，因此ALU必须可直接访问MDR和用户可见寄存器，ALU的外围还可以有另一些寄存器，这些寄存器用于ALU的输入/输出以及用于和MDR及用户可见寄存器交换数据。

此外，还有用来存放程序状态字PSW的寄存器，该寄存器用来存放条件码和其他状态信息。在具有中断系统的机器中还有中断标记寄存器。



### 1.3.3 举例

下面以Z8000、8086和MC68000说明:

<img src="./image/ch08_00_02.svg" style="display:block; margin:0 auto;">

1. Z8000
   - 有16个16位的通用寄存器，这些寄存器可存放地址、数据，也可作为变址寄存器，其中有两个寄存器用作栈指针，可给用作8位和32位的运算
   - 有5个与程序状态有关的寄存器，一个用于存放状态标记，两个用于程序计数器，两个用于存放偏移量。
   - 确定一个地址需要两个寄存器
2. 8086
   - 4个16位的数据寄存器，即AX(累加器)、BX(基址寄存器)、CX(计数寄存器)和DX(数据寄存器)，也可兼做8个8位的寄存器(AH、AL、BH、BL、CH、CL、DH、DL)
   - 有两个16位的指针(栈指针SP和基址指针BP)和两个变址寄存器(源基址寄存器SI和目的变址寄存器DI)
   - 还有4个段地址寄存器(代码段CS、数据段DS、堆栈段SS和附件段ES)
   - 以及指令指针IP(相当于PC)和状态寄存器F
3. MC68000
   - 8个数据寄存器，主要用于数据运算，当需要变址时，也可作变址寄存器使用。允许8位、16位和32位的数据运算，由操作码确定。
   - 9个地址寄存器，用于存放32位地址，其中的两个($A_7和A_7'$ ) 也可用作堆栈指针，分别供用户和操作系统使用。针对当前执行的模式，这两个寄存器在某一时刻只能使用一个
   - 还有一个32位的程序计数器PC和16位的状态寄存器。

## 1.4 控制单元和中断系统

控制单元(CU)是提供完成计算机全部指令的微操作命令序列部件。

现代计算机中微操作命令序列形成有:

- 组合逻辑设计方法，为硬连线逻辑
- 微程序设计方法，为存储逻辑。



# 2. 指令周期

## 2.1 指令周期的基本概念

CPU每取出并执行一条指令所需的全部时间称为指令周期，也即CPU完成一条指令的时间。

一个完整的指令周期包括取指、间址、执行和中断4个子周期。

<img src="./image/ch08_01_00.svg" style="display:block; margin:0 auto;">

上述四个周期都有CPU访存操作，不过访存目的不同:

- 取指周期: 取指令
- 间址周期: 取有效地址
- 执行周期: 取操作数(当指令为访存时)
- 中断周期: 保存程序断点

这四个周期又称为CPU的工作周期，在CPU内可设置4个标志触发器来区分:

<img src="./image/ch08_01_01.svg" style="display:block; margin:0 auto;">

## 2.2 指令周期的数据流

### 2.2.1 取指周期数据流

<img src="./image/ch08_01_02.svg" style="display:block; margin:0 auto;">

此时的数据流:

- PC中存放现行指令的地址，该地址送到MAR
- 地址从MAR送到地址总线
- 控制部件CU向存储器发出读命令
- MAR所指单元内容(指令)经数据线送至MDR
- MDR内容送至IR
- CU控制PC内容加1，形成下一条指令的地址

### 2.2.2 间址周期的数据流

<img src="./image/ch08_01_03.svg" style="display:block; margin:0 auto;">

一旦取指周期结束，CU检查IR的内容，确定是否有间址操作，如果需要间址操作，则:

- MDR中指示形式地址的右 N 位 (记作 Ad(MDR)) 将被送到MAR
- MAR地址送到地址总线
- CU向存储器发出读命令
- 获取有效地址并存至MDR

### 2.2.3 执行周期数据流

由于不同的指令在执行周期的操作不同，因此执行周期的数据流是多种多样的。

### 2.2.4 中断周期数据流

<img src="./image/ch08_01_04.svg" style="display:block; margin:0 auto;">

CPU进入中断周期要完成一些列的操作,其中PC把当前的内容保存起来，以待执行完中断服务程序后可以准确返回到该程序的间断处，其数据流为:

- CU把保存程序断点的存储器特殊地址(如栈指针的内容)送往MAR
- MAR把地址送到地址总线上
- CU向存储器发出写命令
- CU将PC的内容(程序断点)送到MDR
- MDR内容经数据总线存入存储器中
- CU将中断服务程序的入口地址送至PC，为下一周期的取值做好准备



# 3. 指令流水

为了进一步提高处理机速度，通常可以:

1. 提高器件的性能

   器件的每一次更新换代都能使计算机的软硬件技术和计算机性能获得突破性进展。

2. 改进系统的结构，开发系统的并行性

   并行包含同时性和并发性，前者是指两个或多个事件在同一时刻发生，后者是指两个或多个事件在同一时间段发生

   并行性体现在不同等级上，通常分为四个级别:

   - 作业级或程序级
   - 任务级或进程级
   - 指令之间级
   - 指令内部级

   前两者为粗粒度，又称过程级，后两者为细粒度，又称指令级。

   粗粒度并行性一般用算法(软件)实现，细粒度并行性一般采用硬件实现。

   粗粒度并行性是在多个处理机上分别运行多个进程，由多台处理机合作完成一个程序；细粒度并行性是指在处理机的操作级和指令级的并行性，其中指令的流水作业就是一项重要技术。

## 3.1 指令流水原理

1. 先简单分析指令只有取指令和执行指令两个过程:

   - 在不采用流水线情况向，取指令和执行指令是周而复始的

     <img src="./image/ch08_02_00.svg" style="display:block; margin:0 auto;">

   - 如果执行指令阶段不访问主存，则完全可利用这段时间取下一条指令，这样就使取下一条指令的操作和执行当前指令的操作同时进行，这就是两条指令的重叠，即指令的二级流水。

     <img src="./image/ch08_02_01.svg" style="display:block; margin:0 auto;">

   - 由指令部件取出一条指令，并将它暂存起来，如果执行部件空闲，就将暂存的指令传给执行部件执行。与此同时，指令部件又可取出下一条指令并暂存起来，这称为指令预取。
   - 进一步分析流水线，有如下原因导致执行效率无法加倍
     - 指令的执行时间一般大于取值周期，取值阶段可能要等待一段时间，也即存放在指令部件缓冲区的指令还不能立即传给执行部件
     - 当遇到转移指令时，下一条指令是不可知的，因为必须等待执行阶段结束后，才能获知条件是否成立。
   - 为减少时间损失，采用猜测法，即当条件转移指令从取指阶段进入执行阶段时，指令部件仍按顺序预期下一条指令。

2. 为了进一步提高处理速度，可将指令处理分解为更细的几个阶段

   - 取指(FI)

     从存储器取出一条指令并暂时存入指令部件的缓冲区

   - 指令译码(DI)

     取定操作性质和操作数地址的形成方式

   - 计算操作数地址(CO)

     计算操作数的有效地址，涉及存储器间接寻址、间接寻址、变址、基址、相对寻址等各种地址计算方式

   - 取操作数(FO)

     从存储器中取操作数(若操作数在寄存器中，则无此阶段)

   - 执行指令(EI)

     执行指令所需的操作，并将结果存于目的位置(寄存器)

   - 写操作数

     将结果写入存储器
   
   假设各个阶段时间相等且不存在存储器访问冲突，则指令六级流水时序如下:
   
   <img src="./image/ch08_02_02.svg" style="display:block; margin:0 auto;">

​     

## 3.2 影响流水线性能的因素

### 3.2.1 结构相关

结构相关是当前指令在重叠执行过程中，不同指令争用同一功能部件产生资源冲突时产生的，又称资源相关。

通常，大多数机器都是将指令和数据保存在同一存储器中，且只有一个访问口，如果在一个时钟周期内，流水线既要完成某条指令对存储器的访问操作，又要完成另一条指令的取值操作，就会发生访问冲突。

解决的办法:

- 可以让流水线在完成一条指令对数据的存储访问时，暂停(一个时钟周期)取后一条指令的操作
- 也可以设置两个独立的存储器分别存放操作数和指令，以免取指令和取操作数同时进行时互相冲突
- 还可以采用指令预取技术，如在CPU中设置指令队列，将指令预先取到指令队列中排队。



### 3.2.2 数据相关

数据相关是流水线中的各条指令因重叠操作，可能改变操作数的读写访问顺序，从而导致数据相关冲突。

根据指令间对同一寄存器读和写的先后次序关系，数据相关冲突可分为:

- 写后读相关(RAW)

  指令j在指令i写入寄存器前就读出该寄存器的内容，这样，指令j就会错误的读出该寄存器旧的内容

- 读后写(WAR)

  指令j视图在指令i读出寄存器之前就写入该寄存器，这样，指令i就错误读出该寄存器新的内容

- 写后写(WRW)

  指令j试图在指令i写入寄存器之前就写入该寄存器，这样两次写入的先后顺序颠倒，就会错误地使由指令i写入的值称为该寄存器的内容

  上述三种数据相关在按序流动的流水线中，只出现RAW相关；而在非按序流动的流水线中，三者都可能发生。



解决数据相关办法:

- 采用后推法

  将相关指令延迟到所需操作数被写回寄存器后在执行的方式。

- 采用定向技术，或旁路技术、相关专用通路技术

  不必等待某条指令的执行结果送回到寄存器，自从寄存器中取出该结果，作为下一条指令的源操作数，而是直接将执行结果送到其他指令所需的地方。

  <img src="./image/ch08_02_03.svg" style="display:block; margin:0 auto;">

  上图中，当AND指令将要进入EX阶段时，ADD指令的执行结果已存取暂存器2，SUB指令执行的结果暂存存储器1，而暂存器2的内容(存放送往$R_1$ 的结果) 可通过旁路通道，经过多路开关送到ALU中。

  ### 3.2.3 控制相关

  控制相关主要是由转移指令引起的。转移指令大约占总指令的1/4,比起数据相关，它会使流水线丧失更多的性能。

  为了解决控制相关，解决办法为:

  - 采用尽早判别转移是否发生，尽早生成转移目标地址
  - 预取转移成功或不成功两个控制流方向上的目标指令
  - 加快和提前形成条件码
  - 条转移方向的猜准率

  

## 3.3 流水线性能

  流水线的性能通常用以下指标衡量

  1. 吞吐率

     单位时间内流水线所完成指令或输出结果的数量，又分为:

     - 最大吞吐率

       在连续流动达到稳定转台或获得的吞吐率。对于m段的指令流水线而言，各段的时间均为 $\Delta t$ ,则最大吞吐率为
       $$
       T_{p max}=\frac{1}{\Delta t}
       $$
       
     - 实际吞吐率
     
       指流水线完成n条指令的实际吞吐率，对于m段指令的流水线，处理n条指令的实际吞吐率为
       $$
       T_{p}=\frac{n}{m\Delta t+(n-1)\Delta t}=\frac{T_{pmax}}{1+(m-1)/n}
       $$
       
     
  2. 加速比

     指m段流水线的速度与等功能的非流水线的速度之比。   n条指令在m段流水线上的加速比为
     $$
     S_P=\frac{nm\Delta t}{m\Delta t+(n-1)\Delta t}=\frac{nm}{m+n-1}=\frac{m}{1+(m-1)/n}
     $$
     
  3. 效率

     指流水线中各功能段的利用率。通常用流水线各段处于工作时间的时空区域与流水线各段的总时空区之比来衡量流水线，即
     $$
     E=\frac{mn\Delta t}{m(m+n-1)\Delta t}=\frac{n}{m+n-1}=\frac{S_p}{m}=T_P\Delta t
     $$
     <img src="./image/ch08_02_04.svg" style="display:block; margin:0 auto;">

  

##   3.4 流水线中的多发技术

为了进一步发展流水线，可以采用:

- 好的指令调度算法
- 重新组织指令执行顺序
- 降低相关带来的干扰
- 优化编译

此外，还可以开发流水线中的多发级数，设法在一个时钟周期(机器主频的倒数)内，产生更多条指令的结果。

现假设一条指令有4条，以下是普通流水:

<img src="./image/ch08_02_05.svg" style="display:block; margin:0 auto;">



下面说明常见的多发技术:

1. 超标量技术 (Super Scalar)

   <img src="./image/ch08_02_06.svg" style="display:block; margin:0 auto;">

   - 它在每个时钟周期内可同时并发多条独立指令，即以并行操作方式将两条或两条以上指令编译并执行。
   - 要实现超标量技术，要求处理机中配置多个功能部件和指令译码电路，以及多个寄存器端口和总线，以便能实现同时执行多个操作，还要编译程序决定那几条相邻指令可并行执行

2. 超流水技术 (Super Pipe Lining)

   <img src="./image/ch08_02_07.svg" style="display:block; margin:0 auto;">

   - 超流水线级数是将一些流水线寄存器插入到流水线段中，好比将流水线在分段。
   - 上图中，将原来的时钟周期又分成3段，在原来的时钟周期内，功能部件被使用3次，使流水线以3倍于原来时钟频率的速度运行。
   - 硬件不能调整指令的执行顺序，考编译程序优化解决问题。

   

3. 超长指令技术 (VLIW)

   <img src="./image/ch08_02_08.svg" style="display:block; margin:0 auto;">

   - 超长指令字技术采用多条指令在多个处理部件中并行处理的体系结构，在一个时钟周期内能流出多条指令
   - 超长字指令是由编译程序在编译时挖掘出指令间潜在的并行性后，把多条能并行操作的指令组合成一条具有多个操作码字段的超长指令(指令字长可达几百位)
   - 由这个超长指令控制VILW机中多个独立工作的功能部件，由每一个操作码字段控制一个功能部件，相当于同时执行多条指令
   - 有较高的并行处理能力，但对优化器的要求高、对Cache容量要求也大

   

   

##   3.5  流水线结构

### 3.5.1 指令流水线结构

指令流水线是指将指令的整个执行过程用流水线进行分段处理，典型的指令执行过程分为:

<img src="./image/ch08_02_09.svg" style="display:block; margin:0 auto;">

### 3.5.2 运算流水线

流水线还可以用于部件级，如浮点运算操作流水线:

<img src="./image/ch08_02_10.svg" style="display:block; margin:0 auto;">

- 流水线在相邻两段在执行不同的操作，因此在相邻两段之间必须设置锁存器或寄存器
- 只有当流水线各段工作各段工作饱满时，才能发挥最大作用



# 4. 中断系统

## 4.1 概述

### 4.1.1 引起中断的各种因素

1. 人为设置的中断

   这种中断一般称为自愿中断，因为它是在程序中人为设置的，故一旦机器执行效率执行这种人为中断，便自愿停止现行程序而转入中断处理

   <img src="./image/ch08_03_00.svg" style="display:block; margin:0 auto;">

   上图中的"转管指令"可能转至从I/O设备调入一批信息到主存的管理程序，也可能是转至将一批数据送往打印机打印的管理程序。

   当用户程序执行"转管指令"后，便可中断现行程序，转入管理程序，这种转移完全是自愿的。

2. 程序性事故

   如定点溢出、浮点溢出、操作码不能识别、除法中出现"非法"等

3. 硬件故障

   如插件接触不良、通风不良、磁表面损坏、电源掉电等

4. I/O设备

   I/O设备启动后，一旦准备就绪，便向CPU发出中断请求。每个I/O设备都能发出中断请求。

5. 外部事件

   用户通过键盘来中断现行程序属于外部事件中断

上述各种中断因素除自愿中断是人为的以外，大多数是随机的。

将引起中断的各个因素称为中断源，中断源可分为两类

- 不可屏蔽中断

  这类中断CPU不能禁止响应，如电源掉电等

- 可屏蔽中断

  CPU可根据该中断源是否被屏蔽来确定是否予以响应。若未被屏蔽则能响应；若已被屏蔽，则CPU不能响应。

### 4.1.2 中断系统需解决的问题

- 各中断源如何向CPU提出中断请求
- 当多个中断源同时提出中断请求时，中断系统如何确定优先响应哪个中断源的请求
- CPU在什么条件、什么时候、什么方式来响应中断
- CPU响应中断后如何保护现场
- CPU响应中断后，如何停止原程序的执行而转入中断服务程序
- 中断处理结束后，CPU如何恢复现场，如何返回到原程序的间断处
- 在中断处理过程汇中又出现了了新的中断请求，CPU该如何处理



## 4.2 中断请求标记和中断判优逻辑

### 4.2.1 中断请求标记

为了判断是哪个中断源提出的请求，在中断系统中必须设置中断请求标记触发器，简称中断请求触发器，记作INTR。当其状态为“1”时，表示中断源有请求。

下图是集中在CPU中断系统内的中断请求标记:

<img src="./image/ch08_03_01.svg" style="display:block; margin:0 auto;">

需要注意的是，尽管中断请求标记寄存器是由个中断触发器组成的，但这些触发器既可以集中在CPU的中断系统内，也可以分散到各个中断源中。



### 4.2.2 中断判优逻辑

任何一个中断系统，在任一时刻，只能响应一个中断源的请求。但许多中断源提出的请求都是随机的，当某一时刻有多个中断源提出中断请求时，中断系统必须按其有限顺序予以响应，称为中断判优。

各中断源的优先顺数是根据该中断源若得不到及时响应，致使机器工作出错的严重程度而确定的。如:电源掉电对计算机工作影响程度最大，优先级最高；"定点溢出"对机器正常工作影响也很大，若不及时响应，将使计算机一切运行无效。

中断判优可由如下实现:

1. 硬件排队

   硬件排队分为两种:

   - 链式排队器

     <img src="./image/ch05_04_01.svg" style="display:block; margin:0 auto;">

     对应中断请求触发器分散在各个接口电路，每个接口电路有设有一个非门和一个与非分门

   - 排队器设在CPU内

     <img src="./image/ch08_03_02.svg" style="display:block; margin:0 auto;">

     当最高优先级的中断源有请求时 $\text{INTR}_i=1$ ,就可以封住比它级别低的中断源的请求。

2. 软件排队请求

   通过编写查询程序实现

   <img src="./image/ch08_03_03.svg" style="display:block; margin:0 auto;">

## 4.3 中断服务程序入口地址的寻找

通常由两种方法寻找入口地址:

1. 硬件向量法

   - 利用硬件产生向量地址，再由向量地址找到中断服务程序的入口。

   - 向量地址由中断向量地址形成部件产生，这个电路可以分散在各个接口电路中，也可设在CPU内。

   - 由向量地址寻找中断服务程序入口两种方法

     - 在向量地址内存放一条无条件转移指令，CPU响应中断时，只要将向量地址送至PC，便可无条件转向程序入口地址。

     - 设置向量地址表，该表设在存储器内，存储单元地址为向量地址，存储单元的内容为入口地址。

       <img src="./image/ch08_03_04.svg" style="display:block; margin:0 auto;">

   

2. 软件查询方法

   用软件查找中断服务程序入口，至于各中断源对应的入口地址，则由程序员(或系统)事先确定。

   这种方法不涉及硬设备，但查询时间较长。

## 4.4 中断响应

### 4.4.1 响应中断的条件

当EINT=1，且有中断请求(即中断请求标记触发器INTR=1)时，CPU可以响应中断。

### 4.4.2 响应中断的时间

CPU总是在指令执行周期结束后，响应任何中断源的请求。

在指令执行周期结束后，若有中断，CPU则进入中断周期;若无中断，则进入下一条指令的取值周期。

<img src="./image/ch08_03_05.svg" style="display:block; margin:0 auto;">

之所以CPU在指令的执行周期后进入中断周期，是因为CPU在执行周期结束时刻同一向所有中断源发出中断查询指令，只有此时，CPU发出中断查询信号到触发器的时钟端，才能将 $\text{INTR}_i$ 置 "1".

在某些计算机中，有些指令执行时间很长，可在指令执行过程中设置若干个查询断点，CPU在每个查询断点时刻均发出中断信号，以便发现有中断请求便可及时响应。



### 4.4.3 中断隐指令

CPU响应中断后，即进入中断周期，在中断周期内，CPU要自动完成一系列操作:

1. 保护程序断点

   将当前程序计数器PC的内容(程序断点)保存到存储器中。可以保存到存储器的特定单元(如0号地址)内，也可存入堆栈。

2. 寻找中断服务程序的入口地址

   有两种方法:

   - 在中断周期内，将向量地址送至PC(对应硬件向量法),使CPU执行下一条无条件转移指令，转至中断服务程序的入口地址
   - 在中断周期内，将软件查询入口地址的程序(又称中断识别程序)首地址送至PC，是CPU执行中断识别程序，找到入口地址(对应软件查询法)

3. 关中断

   为了确保CPU响应后所需做的一些列操作不至于又收到新的中断请求的干扰，在中断周期内必须自动关中断，以禁止CPU再次响应新的中断请求。

   <img src="./image/ch08_03_06.svg" style="display:block; margin:0 auto;">

   上图中:

   - 允许中断触发器EINT和中断触发器INT选用标准的S-R锁存器
   - 当进入中断周期时，INT为"1"状态，触发器原端输出有一个正跳变，进过反向后产生一个负跳变，使EINT置"0"，即关中断

   

上述保护断点、寻找入口地址和关中断这些操作都是在中断周期内由一条中断隐指令完成的。

所谓中断隐指令，即在机器指令系统中没有的指令，它是CPU在中断周期内由硬件自动完成的一条指令。



## 4.5 保护现场和恢复现场

保护现场应包括程序断点保护和保护CPU内部各寄存器内容的现场两个方面。程序断点的现场保护由中断隐指完成，各寄存器内的现场保护可在中断服务程序中由用户(或系统)用机器指令编程实现。

恢复现场是指在中断返回前，必须将寄存器的内容恢复到中断处理前的转台，这部分工作由中断服务程序完成。





## 4.6 中断屏蔽技术

### 4.6.1 多重中断的概念

当CPU正在执行某个中断服务程序时，另一个中断源又提出了新的中断请求，而CPU又响应了这个新的请求，暂时停止正在运行的服务程序，转去执行新的中断服务程序，这称为多重中断，又称嵌套中断。

<img src="./image/ch08_03_07.svg" style="display:block; margin:0 auto;">

如果CPU对新的请求不予响应，待执行完当前的服务程序后在响应，记为单重中断。



### 4.6.2 实现多重中断的条件

1. 提前设置"开中断"指令

   CPU进入中断周期后，由中断隐指令自动将EINT置"0",即关中断，CPU若想再次响应中断请求，必须开中断，这一响应通常由中断服务程序中的开中断指令实现。

2. 优先级别高的中断源有权中断优先级别低的中断源

   例如，有A、B、C、D4个中断源，其优先级 $A\to B\to C\to D$ 由高到低，则下面多重中断的处理示意图:

   <img src="./image/ch08_03_08.svg" style="display:block; margin:0 auto;">

   为了保证底级别的中断源不干扰比其级别高的中断源的中断处理过程，可采用屏蔽技术

3. 屏蔽技术

   - 屏蔽触发器与屏蔽字

     <img src="./image/ch08_03_09.svg" style="display:block; margin:0 auto;">

     - 当中断源被屏蔽(MASK=1)，此时即使D=1，中断查询信号到来时刻只能将INTR置"0",CPU接收不到该中断源请求，即它被屏蔽
     - 若该中断源未被屏蔽(MASK=0),当设备工作已完成(D=1)时，中断查询信号将INTR置"1"，表示该中断源向CPU发出中断请求，该信号送至排队器进行优先级判断

     对应每个中断请求触发器就有一个屏蔽触发器，将所有屏蔽触发器组合在一起，便构成一个屏蔽寄存器，屏蔽寄存器的内容称为屏蔽字。

     屏蔽字与中断源的优先级别是一一对应的：

     |  优先级  |      屏蔽字      |
     | :------: | :--------------: |
     |    1     | 1111111111111111 |
     |    2     | 0111111111111111 |
     |    3     | 0011111111111111 |
     |    4     | 0001111111111111 |
     |    5     | 0000111111111111 |
     |    6     | 0000011111111111 |
     | $\vdots$ |     $\vdots$     |
     |    15    | 0000000000000011 |
     |    16    | 0000000000000001 |

     在中断服务程序中设置适当的屏蔽字，能起到对优先级别不同的中断源的屏蔽作用。

   - 屏蔽技术可改变优先级

     优先级包括响应优先级和处理优先级。

     - 响应优先级: CPU响应各中断源请求的优先次序，这种顺序往往是硬件线路已设置好的，不便于改动
     - 处理优先级:CPU实际对个中断源请求的处理优先顺序

     采用屏蔽技术后，可以改变CPU处理各中断源的优先等级。

     例如: 有A、B、C、D这四个中断源,其优先级 $A\to B\to C\to D$ 由高到低。如果不采取屏蔽技术，则处理次序与响应次序一致:

     <img src="./image/ch08_03_10.svg" style="display:block; margin:0 auto;">

     如果将上述4个中断源处理次序改为 $A\to D\to C\to B$  ,则对应的屏蔽字发生变化:

     | 中断源 | 原屏蔽字 | 新屏蔽字 |
     | :----: | :------: | :------: |
     |   A    |   1111   |   1111   |
     |   B    |   0111   |   0100   |
     |   C    |   0011   |   0110   |
     |   D    |   0001   |   0111   |

     在同样请求下，CPU执行程序的轨迹为:

     <img src="./image/ch08_03_11.svg" style="display:block; margin:0 auto;">

     采用屏蔽技术后，在中断服务程序需设置新的屏蔽字，流程图如下:

     <img src="./image/ch08_03_12.svg" style="display:block; margin:0 auto;">

   - 屏蔽技术的其他应用

     屏蔽技术还能给程序控制带来更大的灵活性。

4. 多重中断的断点保护

   - 多重中断时，每次中断出现的断点都要保存起来。

   - 中断系统对断点的保存都是在中断周期内由中断隐指令实现的，对用户是透明的。
   - 断点可以保存在堆栈中
   - 断点也也可以保存在特定的存储单元内，如果约定一律将程序断点保存在主存的0号地址单元内，则中断服务程序中的开中断指令前，先将0地址单元的内容转存至其他地址单元内，才能真正保存每一个断点。

   

   
