# 1. 机器指令

机器语言由一条条语句构成，每一条语句又能准确表达某种语义。把每一条机器语言称为机器指令，将全部的机器指令的集合称为机器的指令系统。

## 1.1 指令的一般格式

指令是由操作码和地址码组成

<img src="./image/ch07_00_00.svg" style="display:block; margin:0 auto;">

### 1.1.1 操作码

用来指明所要完成的操作，如加法、减法、传送、移位、转移等。其位数反映了机器的操作种类，即机器允许的指令条数。

操作码的长度可以是固定的，也可以是变化的。前者是将操作码集中放在指令的一个字段内。

对于操作码长度不固定的指令，其操作码分散在指令的不同字段中，通常采用拓展操作码级数，使操作码的长度随地址数的减少而增加，下图是一种拓展操作:


<img src="./image/ch07_00_01.svg" style="display:block; margin:0 auto;">

### 1.1.2 地址码

地址码用来指出该指令的源操作数的地址(一个或两个)、结果的地址以及下一条指令的地址。地址可以是主存的地址,也可以是寄存器的地址，甚至是I/O设备的地址。

下面分析主存地址：

1. 四地址指令

   这种指令的地址字段有4个:

   <img src="./image/ch07_00_02.svg" style="display:block; margin:0 auto;">

   其中:

   - OP为操作码
   - $\text{A}_1$ 为第一操作数地址
   - $\text{A}_2$ 为第 二操作数地址
   - $\text{A}_3$ 为结果地址
   - $\text{A}_4$ 下一条指令地址

   该指令完成$(\text{A}_1)\text{OP}(\text{A}_2)\to \text{A}_3$ 的操作。

   如果指令字长为32位，操作码占8位，4个地址字段各占6位，则指令操作数的寻址范围为 $2^6=64$ 。

    若地址字段均指示主存的地址，需要访问4次存储器(取指令1次，取两个操作数2次，存放结果1次)

   因程序大多按顺序执行，而程序计数器PC既能存放当前欲执行的指令地址，又有计数功能，它能自动形成下一条指令的地址，于是，将$A_4$ 省去，可得三地址指令

2. 三地址指令

   三地址指令的格式如下：

   <img src="./image/ch07_00_03.svg" style="display:block; margin:0 auto;">

   它可以完成 $(\text{A}_1)\text{OP}(\text{A}_2)\to \text{A}_3$ 的操作，后续指令的地址隐含在程序计数器PC之中。

   和上述指令字长一样，若OP仍为8位，则3个地址字段各占8位，直接寻址范围为 $2^8 = 256$ 。

   若地址字段均为主存地址，也需要访问4次存储器。

   机器在运行过程中，没有必要将每次运算的结果都存入主存，中间结果可以暂时存放在CPU的寄存器(如ACC)中，这样又可以省去 $\text{A}_3$ ，得到二地址指令

3. 二地址指令

   二地址指令格式如下:

   <img src="./image/ch07_00_04.svg" style="display:block; margin:0 auto;">

   它可以完成 $(\text{A}_1)\text{OP}(\text{A}_2)\to \text{A}_1$ 的操作，也可以完$(\text{A}_1)\text{OP}(\text{A}_2)\to \text{A}_2$ 的操作，二者都需要访问4次存储器；如果它完成 $(\text{A}_1)\text{OP}(\text{A}_2)\to \text{ACC} $ 操作，只需访问3次存储器，中间结果暂存在累加器ACC中。

   和上述指令和操作码长度一致，二地址指令操作数的直接寻址范围为 $2^{12}=4\ \text{K}$

   如果将一个操作数的地址隐藏在运算器ACC中，则指令中只需给出一个地址码，构成一地址指令

4. 一地址指令

   一地址指令的格式如下：

   <img src="./image/ch07_00_05.svg" style="display:block; margin:0 auto;">

   它可以完成 $(\text{ACC})\text{OP}(\text{A}_1)\to \text{ACC}$ 的操作，完成一条指令需要访存2次。

   和上述指令和操作码长度一致，一地址指令的直接寻址范围可达 $2^{24}=16\text{M} $ 

5. 零地址指令

   在指令中无地址码，如空操作(NOP)、停机(HLT) 这类的指令只有操作码。而子程序返回(RET)、中断返回(INET) 这类指令没有地址码，其操作数的地址隐藏在堆栈指针SP中。



上述地址都为主存地址，实际上地址字段也可以用来表示寄存器。地址字段表示寄存器时，在指令的执行阶段都不必访问存储器，直接访问寄存器，使机器的运行速度得到提高，只需在取指阶段访问一次存储器。

## 1.2 指令字长

指令字长取决于操作码的长度、操作数地址的长度和操作数地址的个数。

早期的计算机指令字长、机器字长和存储字长均相等，这种机器指令字长是固定的，控制方式简单。

随着计算机法则，一台机器的指令系统可以采用位数不同的指令。

# 2. 操作数类型和操作类型

## 2.1 操作数类型

机器中常见的操作数类型有:

1. 地址

   地址实际上也可以看做是一种数据，在许多情况下要计算操作数的地址，这时操作数可被认为是一个无符号的整数。

2. 数字

   常见的有定点数、浮点数和十进制

3. 字符

   普遍采用ASCII码，也有用8位EBCDIC码（又称拓展BCD交换码）。

4. 逻辑数据

   计算机除了作算术运算外，有时还需作逻辑运算，此时 $n$ 个0和1的组合不是被看做算术数字，而是被看成逻辑数。

## 2.2 数据在存储器中的存放方式

通常计算机中的数据存放在存储器或寄存器中，而寄存器的位数可以反映机器字长，一般机器字长可取字节的1、2、4、8倍，便于字符处理。

数据可以按"边界对准"存放，也可以按“不对准边界”存放(此时数据可在两个存储单元中，需要访问两次存储器，并对高低字节的位置进行调整后，才能得到一个字)。

<img src="./image/ch07_01_00.svg" style="display:block; margin:0 auto;">

计算机可以按字节、半字、字、双字访问。在对准边界的32位字长计算机中，半字地址是2的整数倍，字地址是4的整数倍，双字地址是8的整数倍。当所存数据不满足要求时，可以填充一个至多个空白字节。

计算机中的字节的次序有:

- 低字节为低地址
- 高字节为低地址

<img src="./image/ch07_01_01.svg" style="display:block; margin:0 auto;">

## 2.3 操作类型

几乎所有的机器包含以下几类通用操作

1. 数据传送

   数据传送包括寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的传送。如：

   - 从源到目的之间的传送
   - 对存储器读(LOAD)和写(STORE)
   - 交换源和目的内容
   - 置1清零
   - 进栈和出栈

2. 算术逻辑运算

   可以实现算术运算(加、减、乘、除、增1、减1、取负数即求补)和逻辑运算(与、或、非、异或)。

   低档机支持最基本的二进制的加减、比较、求补等

   高档机支持浮点运算和十进制运算

   有些机器还有位操作功能，如位测试、位清除、位求反等

3. 移位

   移位可分为算术移位、逻辑移位和循环移位

4. 转移

   转移按转移特征分为;

   - 无条件转移

     不受任何条件约束，可直接把程序转移到一条所需执行指令的地址：如"JMP X"，即指令地址无条件转至X

   - 条件转移

     根据当前指令的执行结果来决定是否需要转移。若满足条件，则转移；若不满足条件，则继续按顺序执行。

     一般机器都能提供一些条件码，如:

     - 零标志位(Z) ,结果为0，Z=1
     - 负标志位(N)，结果为负，N=1
     - 溢出标志位(V), 结果有溢出，V=1
     - 进位标志位(C),最高位有进位，C=1
     - 奇偶标志位(P)，结果呈偶数，P=1

     还有一种指令，SKP,它暗示其下一条指令将被跳过，从而隐含了转移地址的SKP后的第二条指令。

   - 调用与返回

     在编写程序时，有些具有特定功能的程序段会被反复使用。为避免重复编写，可将这些程序设定为独立子程序，当需要执行某子程序是，只需要用子程序调用指令即可。

     计算机系统还提供了通用子程序，如申请资源、读写文件、控制外设等，需要时可由用户直接调用，不必重新编写。

     通常调佣指令包括过程调用、系统调用和子程序调用，可实现从一个程序转移到另一个程序的操作。

     调用(CALL) 一本与返回指令(RETURN) 配合使用。CALL用于从当前的程序位置转至子程序的入口；RETURN用于子程序执行完成后重新返回到原程序的断点。如下图：

     <img src="./image/ch07_01_02.svg" style="display:block; margin:0 auto;">

     需要注意一下几点:

     - 子程序可在多处被调用
     - 子程序调用可出现在子程序中，即允许子程序嵌套
     - 每个CALL指令都对应一条RETURN指令

     由于可以在许多处调用子程序，因此，CPU必须记住返回地址，使子程序能准确返回，返回地址可存放在:

     - 寄存器内。机器内设有专用的寄存器，专门用于存放返回地址
     - 子程序的入口地址
     - 栈顶内。现代计算机都设有堆栈，执行RETURN指令后，便可自动从栈顶取出返回的地址。

   - 陷进(Trap) 与陷阱指令

     陷进其实是一种以外事故的中断。一旦出现意外故障，计算机就发出陷进信号，暂停当前程序的执行，转入故障处理程序进行相应的故障处理。

     计算机的陷进指令一般不提供给用户直接使用，而作为隐指令，在出现故障时，由CPU自动产生并执行。也有的机器设置用户使用的陷进指令或"访管"指令，利用它完成系统调用和程序请求，。

   - 输入和输出

     对于I/O单独编址的计算机而言，通常设有输入输出指令，它完成从外设的寄存器读入一个数据到CPU的寄存器内，或将数据从CPU的寄存器输出至某外设的寄存器中。

   - 其他

     包括等待指令、停机指令、空操作指令、开中断指令、关中断指令、置条件指令等。

     有的计算机还设有非数值处理指令，如字符串传送、字符串比较、字符串查询以及字符串转换等

     在多用户、多任务计算机中，还设有特权指令，这类指令只能由操作系统或其他系统软件，用户不能直接操作

     在大型或巨型机中，还设有向量指令。

   

# 3. 寻址方式

## 3.1 指令寻址

指令寻址分为

- 顺序寻址

  通过程序计数器PC加1，自动形成下一条指令的地址

- 跳跃寻址

  通过转移类指令实现

  <img src="./image/ch07_02_00.svg" style="display:block; margin:0 auto;">

## 3.2 数据寻址

数据寻址方式种类较多，在指令中必须设置一字段来说明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的真实地址称为有效地址，记为EA，由寻址方式和形式地址来决定。

指令的格式如下:

<img src="./image/ch07_02_01.svg" style="display:block; margin:0 auto;">

### 3.2.1 立即寻址

<img src="./image/ch07_02_02.svg" style="display:block; margin:0 auto;">

立即寻址的特点是操作数本身设在指令字内，即形式地址A 不是操作数的地址，而是操作数本身，又称为立即数。

数据是采用补码形式存放的，"#" 表示立即寻址特征标记。

优点是只要取出指令，便可立即获得操作数，在执行阶段不必访问存储器；缺点是A的位数限制了指令所能表述的立即数范围。



### 3.2.2 直接寻址

<img src="./image/ch07_02_03.svg" style="display:block; margin:0 auto;">

指令中的形式地址A就是操作数的真实地址EA，即
$$
\text{EA}=\text{A}
$$
优点是寻找操作数简单，不需要专门计算操作数的地址，在指令执行阶段对主存访问一次。

缺点在于A的位数限制了操作数的寻址范围，而且必须修改A的值，才能修改操作数的地址。

### 3.2.3 隐含寻址

隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。

例如：

一地址格式的加法指令只给出一个操作数的地址，另一个操作数隐含在累加器ACC中。

<img src="./image/ch07_02_04.svg" style="display:block; margin:0 auto;">

由于隐含寻址在指令字中少了一个地址，因此，这种寻址方式有利于缩短指令字长。



### 3.2.4 间接寻址

指令中的形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址，有效地址是由形式地址间接提供的，记为间接寻址，即 EA=(A) 。

<img src="./image/ch07_02_05.svg" style="display:block; margin:0 auto;">

上图显示了一次间接寻址和多次间接寻址，当多次间接寻址时，可用存储字的首位来标志间接寻址是否结束，当存储字首地址为"1"是，还需要继续访存寻址。

优点:

- 和直接寻址相比，间接寻址扩大了操作数的寻址范围，设指令字长和存储字长都为16位，A为8位，则直接寻址范围为 $2^8$ ，一次间接寻址范围为 $2^{16}$ 

- 便于编程，例如，可以用间接寻址完成子程序返回:

  <img src="./image/ch07_02_06.svg" style="display:block; margin:0 auto;">

  ​	上图表示两次调用子程序，只要在调用前先将返回地址存入子程序最末条指令的形式地址A的存储单元内，便可准确返回到程序断点。

  ​	上图中，第一次调用时，使[A]=81，第二次调用前，使[A]=202。

缺点:

- 指令的执行阶段需要访存两次(一次间接寻址)或多次(多次间接寻址)，致使指令执行的时间延长。

### 3.2.5 寄存器寻址

地址码字段直接指出了寄存器的编号，即 $\text{EA}=\text{R}_i$ ，其操作数在 $\text{R}_i$ 所指的寄存器内。

<img src="./image/ch07_02_07.svg" style="display:block; margin:0 auto;">

寄存器寻址在指令执行阶段无须访存，减少了执行时间，由于地址字段只需指明寄存器编号(计算机中寄存器数有限)，故指令字较短，节省存储空间。因此寄存器寻址在计算机中得到广泛应用。

### 3.2.6 寄存器间接寻址

下图是寄存器间接寻址过程:

<img src="./image/ch07_02_08.svg" style="display:block; margin:0 auto;">

图中的 $\text{R}_i$ 中的内容不是操作数，而是操作数所在主存单元的地址号，即有效地址 $\text{EA}=(\text{R}_i)$ 。

与寄存器寻址相比，指令执行阶段还需要访问主存；与间接寻址相比，少了一次访存。

### 3.2.7 基址寻址

基址寻址需要设有基址寄存器BR，其操作数的有效地址EA等于指令字汇总的形式地址与基址寄存器中的内容(称为基地址)相加，即
$$
\text{EA}=\text{A}+(\text{BR})
$$
下图是基址寻址过程:

<img src="./image/ch07_02_09.svg" style="display:block; margin:0 auto;">

基址寻址分为:

- 隐式

  在计算机内专门设有一个基址寄存器BR，使用时用户不必明显指出该基址寄存器，只需由指令的寻址特征位反映出基址寻址即可。

- 显式

  在一组通用寄存器里，由用户明确指出哪个寄存器做基址寄存器，存放基址地址。



基址寻址可以扩大操作数的寻址范围，可将主存地址划分为若干段，每段的首地址存于基址寄存器中，段内的位移量由指令中形式地址A指出。只要修改基址寄存器的内容，便可访问主存的任一单元。

基址寻址在多道程序中极为有用。用户不必考虑自己的程序存于主存的哪一空间区域，完全可由操作系统或管理程序根据主存的使用状况，赋予基址寄存器内一初始值，便可将用户程序的逻辑地址转化为主存的物理地址。



### 3.2.8 变址寻址

变址寻址与基址寻址极为相似，其有效地址EA等于指令中的形式地址A与变址寄存器IX的内容相加之和，即
$$
\text{EA}=\text{A}+(\text{IX})
$$
下图是变址寻址的过程:

<img src="./image/ch07_02_10.svg" style="display:block; margin:0 auto;">

变址寻址和基址寻址的差别

- 基址寻址主要用于程序或数据分配存储空间，通常由操作系统或管理程序确定，在程序执行过程中其值是不变的，而指令中的A是可变的
- 变址寻址中，变址寄存器的内容是由用户设定的，在程序执行过程中其值可变，而指令中的A是不可变的。主要用于处理数组问题。

有的机器的变址寻址具有自动变址的功能，即每存取一个数据，根据数据的长度(所占字节数)，变址寄存器能自动增量或减量，以便形成下一个数据的地址。

变址寻址还可以与其他寻址方式结合使用。



### 3.2.9 相对寻址

相对寻址的有效地址是将程序计数器PC的内容(即当前指令的地址)与指令地址中的形式地址A相加而成，即
$$
\text{EA}=(\text{PC})+\text{A}
$$
<img src="./image/ch07_02_11.svg" style="display:block; margin:0 auto;">

相对寻址常被用于转移类指令，转移后的目标与当前指令有一段距离，称为相对位移量，它由指令字的形式地址A给出，故A又称位移量。

位移量A可正可负，通常用补码表示。

相对寻址的最大特点是转移地址不固定，它可随PC值的变化而变化，因此，无论程序在主存的哪段区域，都可以正确运行，对于编写浮动程序特别有利。

### 3.2.10 堆栈寻址

堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组(称为硬堆栈)来实现，也可以用主存的一部分空间作堆栈(称为软堆栈)。

堆栈的运行方式可分为先进后出或先见先出两种。



下面以软堆栈为例:

- 可用堆栈指针SP指出栈顶地址，也可用CPU中一个或两个寄存器作为SP。
- 操作数只能从栈顶地址指示的存储单元存或取
- 堆栈寻址可视为一种隐含寻址，其操作数的地址总被隐含在SP中
- 堆栈寻址本质上可视为寄存器间接寻址，因SP可视为寄存器，它存放操作数的有效地址。

<img src="./image/ch07_02_12.svg" style="display:block; margin:0 auto;">

由于SP始终指示着栈顶地址，因此无论是执行进栈(PUSH) 还是出栈(POP)，SP的内容都要发生变化。

若栈底地址大于栈顶地址，每次进栈 $(\text{SP})-\Delta\to \text{SP}$, 每次出栈  $(\text{SP})+\Delta\to \text{SP}$，而$\Delta$ 的取值与主存编码方式有关:

- 按字编码, $\Delta$ 取1
- 按字节编码，需要根据存储字长是几个字节构成才能确定 $\Delta$ ,如字长为16位，则$\Delta$ 为2， 字长为32为， $\Delta$ 为4。



# 4. 指令格式举例

## 4.1 设计指令格式硬考虑的各种因素

用户在编程时既希望指令系统很丰富，便于用户选择，同时还要求机器执行程序时速度快、占用主存空间少、实现高效运行。

此外，为了继承已有的软件，必须考虑新机器的指令与同一系列机器指令系统的兼容性，即高档机必须能兼容低档机的程序运行，称之为"向上兼容"。

指令格式集中体现了指令系统的功能，设计时要考虑:

- 操作类型: 包括指令数及操作的难易程度
- 数据类型: 确定哪些数据类型可以参与操作
- 指令格式: 包括指令字长、操作码位数、地址码位数、地址个数、寻址方式类型，以及指令字长和操作码位数是否可变等
- 寻址方式: 包括指令和操作数的具体有哪些寻址方式
- 寄存器个数:寄存器个数的多少直接影响指令的执行时间。



## 4.2 指令格式举例

### 4.2.1 PDP-8

PDP-8的指令字长统一为12位，CPU内只设有一个通用寄存器，即累加器ACC，其主存被划分为若干容量相等的主存空间(每个相同空间被称为一页)。

<img src="./image/ch07_03_00.svg" style="display:block; margin:0 auto;">

该机的指令格式分为:

- 访存类指令

  属于一地址指令。

  - $0\sim 2$ 位为操作码(之定义了 $000\sim 101$ 六种基本操作)
  - 3、4两位为寻址特征，其中3表示是否间接寻址,4位表示当前页面(PC指示的页面)还是0页面
  - $5\sim 11$ 为地址码

- I/O类指令

  - $0\sim 2$ 位为110作标志
  - $9\sim 11$ 位反映具体的操作内容
  - $3\sim 8$ 位表示设备号，总共可选64种设备

- 寄存器类指令

  为了扩大操作种类，对应操作码为"111"配置了辅助操作码。主要对ACC进行各种操作，如清A、对A取反、对A移位、对A加1、根据A的结果是否跳转等。

### 4.2.2 PDP-11

PDP-11机器字长为16位，CPU内设8个16位通用寄存器，其中两个通用寄存器有特殊作用，一个做堆栈指针SP，一个用做程序计数器PC。

PDP-11指令字长有16位、32位和48位三种,采用操作码拓展技术。

<img src="./image/ch07_03_01.svg" style="display:block; margin:0 auto;">



### 4.2.3 IBM 360 

IBM 360 是32位机器，按字节寻址，并支持多种数据类型，如字节、半字、字、双字(双精度实数)、压缩十进制数、字符串等。在CPU中有16个32位通用寄存器(用户可选定任何一个寄存器作为基址寄存器BR或变址寄存器IX)，4个双进度(64位)浮点寄存器。

指令字长有16位、32位、48位三种

<img src="./image/ch07_03_02.svg" style="display:block; margin:0 auto;">

上图中，有五种格式：

- RR 寄存器-寄存器格式

  两个操作数均在寄存器中，完成 $(\text{R}_1)\text{OP}(\text{R}_2)\to \text{R}_1$ 的操作

- RX 二地址格式的寄存器-存储器型指令

  一个操作数在寄存器中，另一个操作数在存储器中，其有效地址由变址(X)和基址(B)寻址方式求得，可完成  $(\text{R}_1)\text{OP}\ \text{M}[(\text{X})+(\text{B})+\text{D}]\to \text{R}_1$ 的操作

- RS 三地址格式的寄存器-存储器型指令

  完成  $(\text{R}_3)\text{OP}\ \text{M}[(\text{B})+\text{D}]\to \text{R}_1$ 操作

- SI 格式

  I为立即数，它完成 立即数 $\to\text{M}[(\text{B})+\text{D}]$ 的操作

- SS 存储器-存储器型指令

  两个操作位均在存储，用于十进制运算和字符串处理，数据长度字段L可定义一个长度 ($1\sim 256$ 个字符) 或两个长度(每一个为 $1\sim 16$ 个十进制数)，它完成 $\text{M} \ [(\text{B}_1)+\text{D}_1]\ \text{OP} \ \text{M}\ [(\text{B}_2)+\text{D}_2]\to M\ [(\text{B}_1)+\text{D}_1]$ 的操作。



### 4.2.4 Intel 8086/80486 系列机

Intel 8086/80486 系列微型计算机的指令字长为 $1\sim 6$ 个字节，即不定长。



# 5. RISC 技术

RISC即精简指令系统计算机，与其对应的是CISC，即复杂指令系统计算机。

## 5.1 RISC 的产生和发展

在系列机的发展过程中，同一系列计算机指令越来越复杂，当指令过于复杂时，机器的设计周期会很长，资金耗费会更大。

于是人们开始研究CISC，并发现80 - 20 规律，即典型程序中的80%的语句仅仅使用处理机中的20%的指令，而这些指令都是属于简单指令。

RISC经历了3代:

- 第一代以32位数据通路为代表，支持Cache，软件支持较少，性能与CISC体系结构的产品相当,如RISC I、MIPS、IBM801
- 第二代产品提高了集成度，增加了对多处理机系统的支持，提高时钟频率，建立了完善的存储管理体系，软件支持也逐渐完善。已经具有单指令流水线，可同时执行多条指令，每个时钟周期发出一条指令。如R3000处理器
- 第三代RISC产品为64为微处理器，采用了巨型计算机或大型计算机的设计技术--超流水线技术和超标量技术，提高了指令的并行处理能力，每个时钟周期发出2条或3条指令，使RISC处理器的整体性能更好，如R4000处理器



## 5.2 RISC的特征

计算机执行程序所需的时间P可用下式表述
$$
P=I\times C\times T
$$
其中，

- I是高级语言程序编译后在机器上运行的指令数
- C为执行每条机器指令所需的平均机器周期
- T为每个机器周期的执行时间



下表是第二代RISC与CISC机的I、C、T统计，其中I、T为比值，C为实际周期

|      |       I       |       C       |  T   |
| :--: | :-----------: | :-----------: | :--: |
| RISC | $1.2\sim 1.4$ | $1.3\sim 1.7$ |  <1  |
| CISC |       1       |  $4\sim 10$   |  1   |

RISC性能优于CISC $2\sim 5$ 倍



### 5.2.1 RISC主要特点

RISC机应具有如下特点

1. 选取使用频度较高的一些简单指令以及一些很有用但又不复杂的指令，让复杂指令的功能由频度高的简单指令的组合来实现
2. 指令长度固定，指令格式种类少，寻址方式少
3. 只有取数/存数(LAOD/SOTRE)指令访问存储器，其余指令的操作都在寄存器内完成
4. CPU中有多个通用寄存器
5. 采用流水线级数，大部分指令在一个时钟周期内完成，采用超标量和超流水线技术，可使每条指令的平均执行时间都小于一个时钟周期
6. 控制器采用组合逻辑控制，不用微程序控制
7. 采用优化的编译程序

### 5.2.2 RISC Ⅱ 指令系统举例

1. 指令种类

   RISC Ⅱ一共有39条指令，分为以下4类:

   - 寄存器-寄存器操作:移位、逻辑、算术(整数)运算等12条
   - 取/存指令:取存字节、半字、字等16条
   - 控制转移指令:条件转移、调用/返回等6条
   - 其他:存取程序状态字PSW和程序计数器等5条

2. 指令格式

   指令的格式简单，寻址方式较少。RISC Ⅱ 的指令格式只有两种:短立即数格式和长立即数格式。

   指令字长固定为32位，指令字中的每个字段都有固定位置。

   <img src="./image/ch07_04_00.svg" style="display:block; margin:0 auto;">

   上图中:

   - 短立即数格式指令主要用于算逻运算，其中
     - 第 $31\sim 25$ 位为操作码
     - 两个操作数一个在 $\text{rs}_1$ 中，另一个操作数的来源由指令的第13位决定。当其为0时，第二个操作数在寄存器 $\text{rs}_2$ 中；当其为1时，第二个操作数为13位的立即数 $\text{imm}_{13}$ 中
     - 运算结果放在DEST所指示的寄存器 $\text{r}_d$ (共32个)中
     - 指令中的第24位S用来表示是否需要根据运算结果置状态为，S=1表示置状态位，RISC Ⅱ一共有4个状态位:零标志位Z、负标志位N、溢出标志位V、进位标志位C
   - 长立即数指令格式主要用于相对转移指令，此时19位的立即数 $\text{imm}_{19}$ 指出转移指令的相对位移量。

3. 寻址方式

   RISC Ⅱ 指令有两种访存寻址方式。

   - 变址寻址

     如果令寄存器内容为0，则直接变成直接寻址；若令位移量为0，则称为寄存器间接寻址

   - 相对寻址

   对于LOAD指令，可根据计算所得的有效地址，从存储器中读取数据并送入DEST字段所指示的目标寄存器中。

   队友SOTRE指令，是将DEST字段指示的源寄存器中的数取出并存入存储器中。

   

### 5.2.3 RISC指令系统的扩充

   商品化的RISC机，因不同用途，还扩充了一些指令:

   - 浮点指令

     用于科学计算的RISC

   - 特权指令

     为了便于操作系统管理机器，防止用户破坏机器的运行环境而特设特权指令

   - 读后置数指令

     完成度-修改-写，用于寄存器与存储单元交换数据等

   - 一些简单的专用指令



## 5.3 RISC和CISC 的比较

与CISC机相比，RISC的主要优点为:

1. 充分利用VLSI芯片的面积
2. 提高计算机的运行速度
   - RISC机的指令数、寻址方式和指令格式种类较少，而且指令的编码很有规律，因此RISC的指令比CISC的指令要快
   - RISC机内通用寄存器较多，减少访存次数，可加快运行速度
   - RISC机采用寄存器窗口重叠技术，程序嵌套时不必将寄存器内容保存到存储器中，故又提高了执行速度
   - RISC机采用组合逻辑控制，比采用微程序控制的CISC的延迟小，缩短CPU的周期
   - RISC机选用精简指令系统，适合于流水线工作，大多数指令在一个周期内完成。
3. 便于设计，可降低成本，提高可靠性
4. 有效支持高级语言程序





   



