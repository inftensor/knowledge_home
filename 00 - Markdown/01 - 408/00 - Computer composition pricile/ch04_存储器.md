# 1. 存储器的概述

## 1.1	存储器的分类

存储器是计算机系统中的记忆设备，用来存放程序和数据。

存储器按不通的角度可有不同的分法：

### 1.1.1 按存储介质

存储介质是指能寄存"0"、“1”两种代码并能区别两种状态的物质或元器件。

1. 半导体存储器

   存储元件由半导体器件组成的存储器称为半导体存储器。现在的半导体存储器都是用超大规模集成电路工艺制成；

   优点：体积小、功耗低、存取时间短

   缺点：电源消失时，存取的信息也随之丢失

   按材料的不同，又可以分为：

   - 双极型(TTL)半导体

     具有高速的特点

   - MOS半导体存储器

     具有高集成度的特点，制造简单、成本低廉、功耗小

2. 磁表面存储器

   在金属或塑料基体的表面上涂一层磁性材料作为记录介质，工作时磁层随载磁体高速运转，用磁头在磁层上进行读/写操作。

   按载磁体的形状不同，可分为：

   - 磁盘

   - 磁带

   - 磁鼓

	按剩磁状态的不同而区分"0","1";而且剩磁状态不会轻易丢失。

3. 磁芯存储器

   由硬磁材料做成的环状元件，在磁芯中穿有驱动线（通电流）和读出线，这样便可进行读/写操作

   磁芯属磁性材料，是不易失的永久记忆存储器

   缺点是体积大、工艺复杂、功耗大

4. 光盘存储器

   应用激光在记录介质（磁光材料）上进行读/写的存储器，具有非易失性。

   优点：记录密度高、耐用性好、可靠性高、互换性强

### 1.1.2 按存取方式

1. 随机存储器（RAM）

   RAM是一种可读/写存储器，存储器的任何一个存储单元的内容都可以随机存取，而且存取的时间与存储单元的物理位置无关

   根据存储信息的原理，又分为：

   - 静态RAM(以触发器为原理寄存信息)
   - 动态RAM(以电容充放电原理寄存信息)

2. 只读存储器

   只能对其存储的内容读出，不能对其重新写入。

   用于存放固定不变的程序、常数、汉字字库等

   发展(后面会详细介绍)：MROM$\to$PROM$\to$EPROM$\to$EEPROM$\to$Flash Memory

3. 串行访问存储器

   对存储单元进行读/写操作时，需要按其物理位置的先后顺序寻找地址

   例如：

   - 磁带存储器

     不论信息在哪，都要从介质的开始段开始按顺序查找

   - 磁盘（部分串行访问）

     先直接指出该存储其中的某个小区域(磁道)，然后再按顺序访问，直到找到位置，前段是直接访问，后段是串行访问，称为==直接存取存储器==。

     

### 1.1.3 按在计算机中的作用分类

按在计算机的作用不同，主要分为主存储器、辅助存储器、缓冲存储器。

- 主存储器

  可以和CPU直接交换信息

  速度快、容量小、每位价位高

- 辅助存储器

  用来存放当前暂时不用的程序和数据，不能与CPU直接交换信息

  速度慢、容量大、每位价位低

- 缓冲存储器

  速度介于主存和辅存之间，起到缓冲作用。

## 1.2 存储器的层次结构

存储器有3个主要性能指标：速度、容量、每位价格（简称位价）。一般来说，速度越高，位价就越高；容量越大，位价就越低；容量越大，速度越低。

三者关系如下图：

存储系统层次结构主要体现在缓存-主存和主存-辅存两个层次上。

1. 缓存---主存层次

   解决CPU和主存速度不匹配的问题。将CPU近期要用的信息调入缓存，CPU可直接从缓存中获取信息，提高了访问速度。

   主存和辅存之间的数据调动是由硬件自动完成的，对程序员是透明的。

2. 主存---辅存层次

   解决存储系统的容量问题。辅存可以存放大量暂时未用到的数据，当CPU需要时再将辅存内容调入主存，供CPU直接访问。

   主存和辅存之间的数据调动是由硬件和操作系统共同完成的。

在主存---辅存这一层次的发展中，逐渐形成了虚拟存储系统，对于具有虚拟存储器的计算机而言，可用的地址空间远远大于主存空间。

- 虚拟地址：指令地址码大于主存的实际存储单元的个数，又叫虚地址或逻辑地址。
- 物理地址：主存的实际地址，又叫实地址



# 2. 主存储器

## 2.1 概述

主存的实际结构如下：

现代计算机的主存都由半导体集成电路构成，上图的驱动器、译码器和读写电路都制作在存储芯片中，MAR和MDR都制作在CPU芯片内，存储芯片和CPU芯片可通过总线连接。

以下是存储器的读写：

1. 读

   - 由CPU将该字的地址送到MAR，经地址总线送到主存，然后发出读命令
   - 主存接到命令后，将该地址的内容读到数据总线上
   - CPU决定该信息送往何处

2. 写

   - CPU将该字所在主存单元的地址经MAR送到地址总线，并将信息字融入MDR,然后向主存发出写命令
   - 主存接到写命令后，将数据线上的信息写入到对应地址线指出的主存单元


### 2.1.1 主存中存储单元地址的分配

   主存各存储单元的空间位置是由单元地址号来表示的，而地址总线是用来指出存储单元地址号的，根据该地址可读出或写入一个存储字。

常用8位二进制数表示一个字节，存储字长都取8的倍数；通常计算机既可以按字寻址，也可以按字节寻址。

以高字节为字地址称为大端模式；以低字节为字地址称为小端模式。

例如：

### 2.1.2 主存的技术指标

主存的主要技术指标是存储容量和存储速度：

1. 存储容量

   指主存能存放二进制代码的总位数，即
   $$
   存储容量=存储单元个数\times存储字长
   $$
   也可以用字节总数表示，即
   $$
   存储容量=存储单元个数\times 存储字长/8
   $$
   
2. 存储速度

   存储速度是由存取时间和存取周期表示

   - 存取时间

     又称为存取器的访问时间，是指启动一次存储器操作(读或写)到完成该操作所需的全部时间。又可分为

     - 读出时间：从存储器接收到有效地址开始，到产生有效输出所需的全部时间
     - 写入时间：从存储器接收到有效地址开始，到数据写入被选中单元为止所需的全部时间

   - 存取周期

     存储器连续两次独立的存储器操作所需的最小时间，通常存取周期大于存取时间

3. 存储器带宽

   表示单位时间内存储器存取的信息量，单位可用字/每秒或字节/每秒表示。

   以下是提高存储器带宽的方式：

   - 缩短存取周期
   - 增加存储字长，使得每个存取周期可读/写更多的二进制数
   - 增加存储体

## 2.2 半导体存储芯片简介

### 2.2.1 半导体存储芯片的基本结构

半导体存储芯片结构如下：

上图中：

1. 译码驱动能把地址总线送来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成被选中单元的读/写操作
2. 存储芯片通过地址总线、数据总线和控制总线与外部连接。
3. 地址线是单向输入的，位数与芯片容量有关
4. 数据线是双向的，位数与芯片可读出或写入的数据位数有关。数据线的位数与芯片容量有关。
5. 地址线和数据线的位数共同反映存储芯片的容量。
6. 控制线主要有读/写控制线与片选线两种。

### 2.2.2 半导体存储芯片的译码驱动方式

半导体存储芯片的译码驱动方式有两种：

- 线选法

  用一根字选择线，直接选中一个存储单元的各位，其结构简单，适用于容量不大的存储芯片。

- 重合法

  被选单元是由X,Y两个方向的地址决定的。



## 2.3 随机存储器

### 2.3.1 静态RAM

1. 静态RAM基本单元电路

   存储器中用于寄存"0"和"1"代码的电路称为存储器的基本单元电路，下图是由6个MOS管组成的基本单元电路。

   下面讨论读取和写入：

   - 读取

     假设存有"1",即A为高电平：

     - 行、列地址选择信号均有效，使得$T_5,T_6,T_7,T_8$均导通，
     - A点高电平通过$T_6$,
     - 由位线A通过$T_8$作为读出放大器的输入信号
     - 在读选择有效时，将"1"信号读出

   - 写入

     - 将写入代码送至$D_{IN}$端
     - 写选择有效，经过两个放大器，使得两端输出为相反电平
     - 行、列地址有效时，使使得$T_5,T_6,T_7,T_8$均导通
     - 将A与$A'$点置成完全相反的电平，把要写入的信息存到该基本单元

2. 静态RAM芯片举例

3. 静态RAM 读/写时序

   - 读周期时序
   - 写周期时序

### 2.3.2 动态RAM

1. 动态RAM的基本单元电路

   常见的动态RAM基本单元有三管式和单管式两种，它们都是靠电容存储电荷的原理来寄存信息。

   若电容上存有足够多的电荷表示存"1",无电荷表示存"0"。

   - 三管式

     读出时：

     - 先对预充电管$T_4$置一个预充电信号(每列共用一个$T_4$管)，使读数据线达到高电平$V_{DD}$
     - 由读选择线打开$T_2$
     - 如果$T_1$之间的极电容$C_g$有足够的电容，使得$T_1$导通,$T_2,T_1$导通接地，使得读数据线降为零电平，读出"0"信号
     - 如果$C_g$没有足够电荷，则$T_1$截止，读出数据线为高电平，读出'1'信号

     写入时：

     - 将写入信号加到写数据线上
     - 由写选择线打开$T_3$
     - $C_g$随输入信息充电或放电

   - 单管式

     读出时：

     - 字线上的高电平使$T$导通
     - 若$C_g$有电荷，经$T$管在数据线上产生电流，读出"1"
     - 若$C_g$无电荷，则数据线上无电流，读出"0"
     - 读出后，电荷已经释放，是破坏性读出，必须再生
     
      写入时：
     
     - 字线为高电平使$T$导通
     - 若数据线为高电平，经过$T$管对$C_g$充电，使其存"1"
     - 若数据线为低电平，则$C_g$经过$T$放电，使其无电荷存"0"
     
     

2. 动态RAM芯片举例

3. 动态RAM 时序

   读时序

   写时序

4. 动态RAM 的刷新

   刷新的过程实质上是先将原来存有的信息读出，再由刷新放大器形成原有信息并重新写入的再生过程。

   必须采用定时刷新的方法，对动态RAM的全部基本单元电路必须做一次刷新，一般取2ms，这个时间称为刷新周期，又称再生周期。

   刷新是一行一行进行的，必须在刷新周期内，由专用的刷新电路完成。

   常见的刷新方法有：

   1. 集中刷新

      集中刷星规定在一个刷新周期内，对全部存储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。

   2. 分散刷新

      每行存储单元的刷新分散到每个存取周期完成。其中，把机器的存取周期$t_c$分成两段，前半段$t_M$用来读/写或维持信息，后半段$t_R$用来刷新。

   3. 异步刷新

      在2ms内对所有行进行刷新，每行刷新的时间为一个存取周期，每行刷新的间隔为2ms。

### 2.3.3 动态RAM和静态RAM的比较

动态RAM优点：

- 在同样大小的芯片中，动态RAM的集成度远高于静态RAM
- 动态RAM行、列地址按先后顺序输送，减少了芯片引脚，封装尺寸也减少
- 动态RAM的功耗比静态RAM小
- 动态RAM的价格比静态RAM的价格便宜

静态RAM优点：

- 静态RAM比动态RAM速度快
- 静态RAM不需要配置再生电源，而动态RAM需要



## 2.4 只读存储器

原始的ROM一旦输入信息即不能改变，随着需求变化，ROM内的原始信息也可以改变。

对于半导体ROM而言，基本器件分为MOS型和TTL型两种。

以下从ROM的发展历史探讨ROM：

### 2.4.1 掩模 ROM

掩模ROM有如下特点：

1. 采用重合法驱动，行、列地址分别经过行、列译码器

2. 行选择器和列选择器交叉处既可以有耦合元件MOS管，也可以没有

3. 列选择线各控制一列控制关，每列控制管的输出端共同连接一个读放大器

4. 当选中的行列交叉处有耦合元件MOS管，则导通使得列线输出为低电平，进过读放大器方向输出为高电平，输出"1";

   当选中的行列交叉处没有耦合元件MOS管，会使得列线输出为高电平，进过读放大器方向输出为低电平，输出"0"

5. ROM制成后无法改变行列交叉的MOS管是否存在，用户无法改变原始状态

### 2.4.2 PROM

PROM 可以实现一次性编程的只读存储器，以下是其特点：

1. 由一个双极型电路和熔丝构成基本单元电路。该电路中，

   - 基极：由行线控制，
   - 发射极：与列线之间形成一条镍铬合金薄膜制成的熔丝(可用光刻技术实现)
   - 集电极：接电源$V_{CC}$

   熔丝断和未断可区分其所存信息是"1"或"0"

2. 若存"0",则置耦合元件一大电流，将熔丝烧掉；若存"1"，则耦合处置不大电流，熔丝不断

3. PROM 往往只能实现一次编程，不得再修改



### 2.4.3 EPROM

EPROM 是一种可擦除可编程只读存储器，目前用的最多的是由浮栅雪崩注入型MOS管构成，又称FAMOS型EPROM,其特点如下：

1. 是N型沟道浮动栅MOS电路
2. 如果在漏端D加上正电压，便会形成一个浮动栅，阻止源S与漏D之间的导通，使此MOS管处于"0"状态
3. 如果漏端D上不加正电压，则不能形成浮动栅，MOS管能正常导通，呈"1"
4. EPROM改写可用两种方法：
   - 紫外线照射：擦除时间较长
   - 电器方法：将存储内容擦除
5.  在联机状态下，用字擦除或页擦除方式，既可以局部擦写，又可全部擦写，这种EPROM称为EEPROM

进入到20世纪80年代，出现了一种闪速存储器(Flash Memory),又称快擦型存储器，其特点如下：

1. 既有EPROM的价格便宜、集成度高的优点，又有EEPROM电可擦除重写的优点
2. 具有整片擦除的特点，其擦除、重写的速度快
3. 已具备RAM的功能，可与CPU直接连接，具有高速编程。
4. 是一种高密度、非易失的数据采集和存储器件。



## 2.5 存储器与CPU的连接

### 2.5.1 存储器容量的扩展

1. 位扩展

   位扩展是指增加存储字长，如下图：

2. 字扩展

   字拓展是增加存储器字的数量。如：

   

3. 字、位扩展

   字、为扩展既增加存储字的数量，又增加存储字长。如下图：

### 2.5.1 存储器与CPU的连接

1. 地址线的连接

   通常是将CPU地址的地位与存储芯片的地址线连接；CPU地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号

2. 数据线的连接

   CPU的数据线数与存储芯片的数据线不一定相等，这是需要对存储芯片扩位。

3. 读/写命令线的连接

   CPU的读/写命令线一般可以直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。

4. 片选线的连接

   存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端$\overline{CS}$  是否能接收到来自CPU的片选有效信号。

   片选有效信号与CPU的访存控制信号$\overline{MREQ}$ （低电平有效）有关，因为只有CPU要求访存时，才需要选择存储芯片

   片选信号还和地址有关，那些未与存储芯片连上的高位地址必须和访存控制信共同产生存储芯片的片选信号。

5. 合理选择存储芯片

   主要是指存储芯片类型(RAM或ROM)和数量的选择，一般选用ROM存放体统程序、标准子程序和各类常数；RAM则是为用户编程而设置。

## 2.6 存储器的校验

### 2.6.1  汉明码的组成

汉明码具有一位纠错能力。由编码纠错理论得知，任何一种编码能否具有检测能力和纠错能力，都与编码的最小距离有关。

最小距离：在任何一种编码系统中，任意两组合法代码之间最少二进制位数的差异。

依据纠错理论，有：
$$
L-1=D+C\quad 且D\ge C
$$
其中$L$为编码最小距离，$D$为检测错误的位数,$C$为纠正错误的位数。

假设要检测的二进制代码为$n$位，要添加$k$位检测位，为了能准确对错误定位以及指出代码没错，则$k$需要满足:
$$
2^k\ge n+k+1
$$
于是可得下表：

|   n    | k(最小) |
| :----: | :-----: |
|   1    |    2    |
|  2~4   |    3    |
|  5~11  |    4    |
| 12~26  |    5    |
| 27~57  |    6    |
| 58~120 |    7    |

确定了$k$之后，便可按进行海明编码：

设$n+k$为代码自左向右一次编码为$1,2,3,\dots,n+k$位，将$k$位记作$C_i(i=1,2,4,8,\dots)$，分别安插在$n+k$为代码编号的第$1,2,4,8,\dots,2^{k-1}$位上。这些检测位负责检测所在小组中1的个数为奇数或偶数，其小组划分如下：

1. $g_i$小组独占第$2^{i-1},i=(1,2,3,\dots)$
2. 每两小组$g_i$和$g_j$共同占有第$2^{i-1}和2的2^{j-1}$位
3. 每3个小组$g_i, g_j,g_k$共同占有$2^{i-1}, 2^{j-1}, 2^{k-1}$
4. $\dots$

### 2.6.2 汉明码的纠错过程

对传送后的汉明码形成新的检测位$P_i(i=1,2,4,8,\dots)$,根据$P_i$的状态，便可直接指出错误的位置。$P_i$的状态是由源检测位$C_i$ 及所在的小组内"1"的个数确定的。

对任意不同n位的信息，先求出虚增加的检测位位数k，再确定$C_i$的位置，然后按奇或偶原则配置$C_i$ 各位的值即可（按奇与按偶配置所求的$C_i$值正好相反）。

## 2.7  提高访存速度的措施

### 2.7.1 单体多字系统

由于程序和数据在存储体内时连续存放的，则CPU访问取出的信息也是连续的，如果可以在一个存取周期内，从同一地址取出n条指令，然后再逐条将指令送至CPU执行，，即每个1/n存取周期，主存向CPU发送一条指令，加大了存储器的带宽。

### 2.7.2 多体并行系统

采用多体模块组成的存储器，每个模块具有相同的容量和存取速度，各模块各自都有独立的MAR和MDR、地址译码器、驱动电路和读/写电路，它们能并行工作，又能交叉工作。

并行工作即同时访问$N$ 个模块，同时启动，同时读出，完全并行地工作（同时读出N个字在总线上需要分时传送）。以下是两种多体模块结构：

1. 高位交叉编址的多体模块结构

   程序按体内地址顺序存放（一个存满后，再存入下一个体），又称顺序存储。高位地址表示体号，低位地址为体内地址

2. 低位交叉编址的多次模块结构

   程序连续存放在相邻体中，又称交叉存储。低位地址表示题体号，高位地址为体内地址。这种编址方法又称模M编址(M为模块数)。

假设每个体的存储字长和数据总线的宽度一致，并假设低位交叉存储器模块数为n，存取周期为T，总线传输周期为$\tau$,则采用流水线之后：

对于低位交叉的存储器，连续读取n个字所需的时间$t_1$为
$$
t_1=T+(n-1)\tau
$$
若采用高位交叉编址，则连续读取n个字所需的时间$t_2$为
$$
t_2=nT
$$
多体模块存储器不仅要和CPU交换信息，还要与辅存、I/O设备，乃至I/O处理机交换信息。在某一时刻，决定主存究竟与哪个部件交换信息必须由存储器控制部件（简称==存控==）来承当。

存控具有合理安排各部件请求访问的顺序以及控制主存读/写操作的功能，其组成如下：

1. 排队器

   防止发生两个以上的请求源同时占用同一个存储体，并防止将代码送到另一个请求源等错误发生，用来确定请求源的优先级别。其规则如下：

   - 对易发生代码丢失的请求源，应列为最高优先级：如外设
   - 对严重影响CPU工作的请求源，给予次高优先级，否则影响CPU工作。

2. 存控触发器$C_M$

   接收排队器的输出信号，一旦相应某请求源的请求，$C_M$被置为"1",以便启动节拍发生器工作。

3. 节拍发生器

   产生固定节拍，与机器主脉冲同步，使控制线路按一定时序发出信号。

4. 控制线路

   将排队器给出的信号与节拍发生器提供的节拍信号配合，想存储器各部件发出各种控制信号，用以实现对总线控制以及完成存储器读/写操作，并向请求源发出各种应答信号，表示存储器已经响应了请求。

### 2.7.3 高性能存储芯片

1. SDRAM(同步DRAM)

   - 它与处理器的数据交换同步于时钟信号，并且以处理器-存储器总线的最高速度运行，不需要插入等待状态
   - SDRAM能在系统时钟的控制下进行数据的读出和写入，CPU给的地址和控制信号会被SDRAM锁存，直到指定的时钟周期后再相应。
   - 支持猝发访问模式，即CPU发出一个地址就可以连续访问一个数据块(通常是32个字节)
   - 还可以包含多个存储体，这些存储体可以轮流工作，提高访问速度
   - 现在新增双数据速率的SDRAM(DDR-SDRAM),每个周期两次向处理器发送数据。

2. RDRAM

   - 采用专用的DRAM和高性能的芯片接口
   - 主要解决存储器带宽问题，通过高速总线获得存储器请求
   - 总线最多可寻址320块RDRAM芯片，传输速率达1.6GBps
   - 各个RDRAM通过互连电路RamLink连成环，数据通信在主存控制器的控制下进行，数据交换以包为单位

3. 带Cache的DRAM(CDRAM)

   带Cache的RDM是在通常的DRAM芯片内又集成了一个小的SRAM，又称增强型的DRAM(EDRAM)。

   下面用一个实际例子说明：

   假设CDRAM为$1M\times 4$ ,其中SRAM为$512\times 4$位，DRAM排列成$2048\times 512 \times 4$位的阵列。

   1. 地址引脚线有11根($A_{10} \sim A_0$),首先在选通信号作用下，高11位地址经地址引脚输入，分别保存在地址锁存器和最后读出行地址锁存器中
   2. 将DRAM2048行中被选中的全部数据$512\times 4$读到SARM中暂存
   3. 列选通信号作用下，低9位地址经地址引脚线输入，保存到列地址锁存器中
   4. 读命令有效时，选中SRAM种某一4位组，经数据线输出。
   5. 下一次读取时，输入的行地址立即与最后读出行锁存器的内容进行比较，若相等，直接从SRAM中获取；若不等，回到1。

   CDRAM优点;

   - 支持猝发式读取，对成块传送有力
   - 芯片内的数据输出路径(SRAM到I/O)与数据输入路径(I/O到读放大器和列选择器)是分开的，允许在写操作完成的同时启动同一行的读操作。

# 3.  高速缓冲器

## 3.1 概述

### 3.3.1 问题的提出

1. I/O设备向主存请求的级别高于CPU访存，就出现了CPU等待I/O设备访存的现象，如果CPU和主存之间加一级缓存，主存可将CPU要取的信息提前送至缓存，I/O与主存交换时，CPU可直接从缓存中读取信息，不必等待。
2. 主存速度发展比不上CPU的发展，需要由高速缓存Cache来解决主存与CPU速度不匹配的问题
3. 指令和数据在主存的地址分布不是随机的，而是相对的聚集，使得CPU执行程序时，访存具有相对的局限性，称为程序访问的局部性原理。

### 3.3.2 Cache的工作原理

设主存有$2^n$个可编址的字，将主存和缓存都分成若干块，每块又包含若干字，并使得它们的块的块大小相同(块内的字数相同)。

1. 主存的地址分为两段：高m位表示主存的块地址，低b位表示块内地址。则$M=2^m$表示主存的块数

2. 缓存也分为两段：高c位表示缓存的块号，低b位表示块内地址，$C=2^c$表示缓存块数，$B=2^b$表示主存和缓存块内的字数，称为快长

3. CPU读取主存某字时，将主存地址的高m位(或m位中的一部分)与缓存块的标记进行比较，判断所读的信息是否在缓存中：

   - 所需的字在缓存中，CPU可直接访问Cache(一般CPU和Cache之间一次传送一个字)
   - 所需字不在缓存中：需要将该字所在的主存整个字块一次调入Cache中（Cache与主存之间是字块传送的）

Cache 的容量与块长是影响Cache效率的重要因素，通常用"命中率"来衡量Cache的效率：

在一个程序执行过程中，设$N_c$为访问Cache的总命中次数，$N_m$为访问主存的总次数，则命中率h:
$$
h=\frac{N_c}{N_c+N_m}
$$
设$t_c$为命中时的Cache访问时间，$t_m$为未命中的主存访问时间，则Cache-主存系统的平均访问时间为
$$
t_a=ht_c+(1-h)t_m
$$
访问效率e为
$$
e=\frac{t_c}{t_m}\times 100\% = \frac{t_c}{ht_c+(1-h)t_m}\times 100\%
$$
一般而言：Cache容量越大，其CPU的命中率越高，但当Cache容量达到一定值时，命中率不随容量的增大二有明显的提高。

当块由小到大是，起初会因局部性原理使命中率提高；若继续增大命中率就会下降。





### 3.3.3 Cache的基本结构

Cache主要由以下模块组成：

1. Cache 存储体

   以块为单位与主存交换信息，为加速Cache与主存之间的调动，主存大多数采用多体结构，且Cache访存的优先级最高

2. 地址映射变换机构

   将CPU送来的主存地址转换为Cache地址，主要是主存块号(高位地址)与Cache块号之间的转换。

   如果转换后的Cache块已与CPU想要访问的主存块建立了关系，则为命中，CPU直接访问Cache存储体。

   如果未建立关系，此刻CPU在访问主存的同时，不仅将该字从主存中取出，同时将它所在的块一并调入Cache,供CPU使用。

   注意，如果Cache未满，则能将主存块调入Cache中，反之要采用替换策略。

3. 替换机构

   当Cache内容已经满时，由替换机构按一定的替换算法来确定从Cache内移出哪个块返回主存，把新的主存块调入Cache

4. Cache 的读写操作

   - 读操作

     - CPU发出主存地址，判断该存储字是否在Cache中
     - 若命中，直接访问Cache,将该字送至CPU中
     - 若未命中，一方面要访问主存，将该字传送给CPU，与此同时，将该字所在的主存块装入Cache,如果Cache已经装满，就要执行替换算法，腾出空位让新的主存快调入

   - 写操作

     目前采用以下的方法：

     - 写直达发：又称存直达法，即写操作时数据既写入Cache又写入主存。能保证主存和Cache一致，但增加了访存次数
     - 写回法：又称拷回法，即写操作时只把数据写入Cache而不写入主存中，但当Cache被替换出去时才写回主存。为了识别Cache中的数据是否与主存一致，Cache的每一块要增设一个标志位，该标志位有两个状态：清和浊。

### 3.3.4 Cache 的改进

   1. 单一缓存和两级缓存
      - 单一缓存：在CPU和主存之间只设一个缓存。随着集成电路逻辑密度的提高，把这个缓存直接与CPU制作在一个芯片内，故又称片内缓存(片载缓存)。
      - 二级缓存：在主存与片内缓存之间再加一级缓存，又称为片外缓存，由静态RAM组成。而且不使用系统总线作为片外缓存与CPU之间的传送路径，使用一个独立的数据路径。
      
   2. 统一缓存和分立缓存

      - 统一缓存：指令和数据都放在同一缓存内
      - 分立缓存：指令和数据分别存放在两个缓存中，一个称为指令Cache,一个称为数据Cache

      两种缓存的选用主要考虑以下因素：

      - 主存的结构
      - 机器对执行的控制方式有关。当采用超前控制或流水线控制时，一般采用分立缓存。
        - 超前控制：当前指令执行过程尚未结束时就提前将下一条准备执行的指令取出，又叫指令预取
        - 流水线控制：多条指令同时执行。

## 3.2 Cache-主存地址映射

### 3.2.1 直接映射

 每个主存块只与一个缓存块相对应，映射关系为：
$$
i = j\ mod \ C \quad 或\quad i=j\ mod\ 2^c
$$
其中，$i$ 为缓存块号，$j$ 为主存块号，$C$ 为缓存块数。

优点：

-  实现简单,只需要利用主存地址的某些位置直接判断,即可确定所需字块是否在缓存中

缺点:

- 不够灵活
- 如果要重复访问对应同一缓存位置的不同主存块,需要不停替换,命中率低



### 3.2.2  全相连映射

允许主存中的每一个字块映射到Cache中的任何一块位置上，可以从已被占满的Cache中替换出任何一旧字块。

特点：

- 灵活、命中率高，减少冲突
- Cache标记位增多，访问是要比较全部的标记位
- 通常用“按内容寻址”的相联存取器完成。
- 所需逻辑电路多，成本高



### 3.2.3  组相联映射

把Cache分为Q组，每组有R块，且有
$$
i = j\ mod\ Q
$$
其中，$i$为缓存的组好，$j$ 为主存的块号。某一主存块按模Q将其映射到缓存的第$i$ 组内。

与直接映射相比，Cache字块地址由c位变为地址字段q位，且$q=c-r$,其中$2^c$表示Cache的总块数，$2^q$表示Cache的分组个数，$2^r$表示组内包含的块数。主存字块标记字段由$t$ 位变为$s=t+r$ 位。

主存的第$j$ 块会映射到Cache 的第$i$ 组中，两者之间一一对应，属于直接连接；同时，主存的第$j$ 块可以映射到Cache 的第$i$ 组中的任一块，又体现出全相联映射关系。





## 3.3 替换策略

### 3.3.1 先进先出（FIFO）算法

FIFO 算法选择最早调入Cache 的字块进行替换，它不需要记录各字块的使用情况，比较容易实现，开销小。

但是没有依据访存的局部性原理，不能提高Cache命中率

### 3.3.2 近期最少使用(LRU) 算法

利用访存局部性原理，替换出近期用得最少的字块。需要记录Cache中各字块的使用情况，以便确定哪个字块近期使用得最少。一般只记录最近一次使用的时间，平均命中率比FIFO高

### 3.3.3 随机法

随机确定被替换的算法，计较简单，但不能提高Cache 的命中率。





